{"version":3,"sources":["../../src/protocol/QueryProtocol.js"],"names":["decodeGraphData","answer","isGraphData","data","type_url","includes","type","demo","protocol","GraphData","decode","value","QueryProtocol","stream","customDataDecoders","queryObject","console","log","query","Query","encode","finish","lengthPrefixed","sink","Promise","resolve","reject","decodeAnswer","source","message","Answer","decodeData","Object","assign","toJSON","toBuffer","e","dataDecoders","defaultDataDecoders","decoder"],"mappings":"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","sourcesContent":["import { demo } from \"lib\";\nimport pipe from \"it-pipe\";\nimport lengthPrefixed from \"it-length-prefixed\";\nimport {take} from \"streaming-iterables\";\nimport toBuffer from \"it-buffer\";\n\n/**\n * The decoder function for GraphData.\n *\n * @param answer\n * @returns {null|GraphData}\n */\nfunction decodeGraphData(answer) {\n\tconst isGraphData = () => {\n\t\treturn answer.data.type_url.includes(\"demo.protocol.GraphData\")\n\t};\n\tif (answer.type !== \"graph\" && !isGraphData()) return null;\n\telse return demo.protocol.GraphData.decode(answer.data.value);\n}\n\nexport default class QueryProtocol {\n\t/**\n\t * Protocol identifier for sending for libp2p.\n\t *\n\t * @type {string}\n\t */\n\tstatic SEND_ID = \"/demo/query/send/1.0.0\";\n\n\t/**\n\t * Protocol identifier for sending for libp2p.\n\t *\n\t * @type {string}\n\t */\n\tstatic RESPOND_ID = \"/demo/query/respond/1.0.0\";\n\n\t/**\n\t * Default decoders for data field of Answer messages.\n\t *\n\t * A decoder must return null if it cannot decode the data field.\n\t * Otherwise it must return the decoded data.\n\t *\n\t * @type {[function(Answer): (null|*)]}\n\t */\n\tstatic defaultDataDecoders = [\n\t\tdecodeGraphData\n\t];\n\n\t/**\n\t * Creates a new QueryProtocol instance which send Query messages and receive Answer messages.\n\t *\n\t * In this demo only GraphData is supported so no custom decoders will be added.\n\t *\n\t * @param stream The stream to send messages to and receive messages from.\n\t * @param customDataDecoders {[function(Answer): (null|*)]} Custom data decoders which get appended to the default data decoders.\n\t */\n\tconstructor(stream, customDataDecoders = []) {\n\t\tthis.stream = stream;\n\t\tthis.dataDecoders = [...QueryProtocol.defaultDataDecoders, ...customDataDecoders];\n\t}\n\n\t/**\n\t * Transforms the query object into its Protocol Buffers equivalent (Query.proto) and\n\t * sends it to the connected peer.\n\t *\n\t * @param queryObject\n\t */\n\tquery = async (queryObject) => {\n\t\tconsole.log(\"Sending query...\");\n\t\tconst query = demo.protocol.Query\n\t\t\t.encode(queryObject)\n\t\t\t.finish();\n\t\treturn pipe(\n\t\t\t// Pipe the query message\n\t\t\t[query],\n\t\t\t// Prefix it with its length\n\t\t\tlengthPrefixed.encode(),\n\t\t\t// The stream sends it\n\t\t\tthis.stream.sink\n\t\t);\n\t};\n\n\t/**\n\t * Decodes the data field of an Answer message.\n\t *\n\t * @param answer The answer message\n\t * @returns The decoded data\n\t */\n\tdecodeData(answer) {\n\t\tfor (const decoder of this.dataDecoders) {\n\t\t\tconst data = decoder(answer);\n\t\t\t// Return once one decoder has been able to decode the data\n\t\t\tif (data !== null) return data;\n\t\t}\n\t}\n\n\t/**\n\t * Awaits an Answer message.\n\t *\n\t * Before calling this method the query method should be called.\n\t * Otherwise no Answer message will be received because nothing has been queried.\n\t *\n\t * @returns {Promise<object>} A promise resolving to the JSON representation of an Answer message once it arrived.\n\t */\n\tawaitAnswer = () => new Promise((resolve, reject) => {\n\t\tconst decodeAnswer = async source => {\n\t\t\tfor await (const message of source) {\n\t\t\t\t// Decode answer\n\t\t\t\tlet answer = demo.protocol.Answer.decode(message);\n\t\t\t\t// Decode data field in answer because this isn't handled by protobuf.js\n\t\t\t\tconst data = this.decodeData(answer);\n\t\t\t\t// Create a copy of the answer because the decoded data gets assigned\n\t\t\t\tanswer = Object.assign({}, {\n\t\t\t\t\ttype: answer.type,\n\t\t\t\t\tdata: data.toJSON()\n\t\t\t\t});\n\t\t\t\tconsole.log(\"Got answer:\", answer);\n\t\t\t\tresolve(answer);\n\t\t\t}\n\t\t};\n\n\t\tconsole.log(\"Awaiting answer...\");\n\t\ttry {\n\t\t\tpipe(\n\t\t\t\t// Read from stream\n\t\t\t\tthis.stream.source,\n\t\t\t\t// Read the prefixed message length\n\t\t\t\tlengthPrefixed.decode(),\n\t\t\t\ttake(1),\n\t\t\t\t// Convert the bytes to a Buffer\n\t\t\t\ttoBuffer,\n\t\t\t\t// Decode the message expecting an Answer message\n\t\t\t\tdecodeAnswer\n\t\t\t);\n\t\t} catch (e) {\n\t\t\treject(e);\n\t\t}\n\t});\n}\n"],"file":"QueryProtocol.js"}